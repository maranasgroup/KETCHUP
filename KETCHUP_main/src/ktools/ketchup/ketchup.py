""" 
KETCHUP functions

collects primary functions for working with KETCHUP-specific models

"""
import pyomo.core.base
from argparse import Namespace
import os


def ketchup_argument_parser() -> Namespace:
    """
    Sets up command-line argument list and returns an argument Namespace for KETCHUP simulation configuration.
    This function uses `argparse` to handle the command-line options.

    Returns
    -------
    argparse.Namespace
        The defined arguments for command-line KETCHUP.
    """
    import argparse

    parser = argparse.ArgumentParser(description="KETCHUP script file")
    parser.add_argument("-s", "--seed",
                        help="Seed value for initializing random number generator. (int between 0 and (2**32 - 1) or string 'time')",
                        default=None, required=False)
    parser.add_argument("-so", "--solver-options", help="Filename of Pyomo solver options file",
                        default=None, required=False)
    parser.add_argument("-po", "--program-options", help="Filename of KETCHUP options file",
                        default=None, required=False)
    parser.add_argument("-tde", "--time-delay", help="Value of time delay in simulations. Units follow data",
                        default=None, required=False)

    args = parser.parse_args()

    return args


def ketchup_process_model_options(data: dict) -> dict:
    """
    Processes and validates model option dictionaries. Currently, resolves relative paths in model option directories.

    Parameters
    ----------
    data : dict
        Model option dictionary.

    Returns
    -------
    dict
        Processed model option dictionary.
    """

    # preprocess model options
    for key, value in data.items():
        # expand current directory if absolute path not used
        if key in ('directory_model', 'directory_data', 'directory_output'):
            try:
                if (value == ".") or (value.startswith("./")):
                    value = os.path.join(os.getcwd(), value[2:])
            except:
                pass
        data[key] = value
    return data


def ketchup_model_options(user_options: dict[str, str | bool | int | None] = None, cmd_args: Namespace = None) -> dict:
    """
    Initializes and updates KETCHUP options from user input, command-line arguments, and, if provided, a program
    options file. Performs validity checks on items such as RNG seed.

    Note that order of precedence is:
        command line arguments for seed and solver options > options file specified on the command line > user
        dictionary argument.

    Parameters
    ----------
    user_options : dict[str, str | bool | int | None]
        A dictionary containing user-specified model options. Its items will overwrite default values.
    cmd_args : argparse.Namespace
        An object containing command-line arguments, generated by `argparse` module. Provides values for
        RNG seed, solver option filename, and program option filename.

    Returns
    -------
    dict[str, str | bool | int | None]
        KETCHUP option dictionary containing the processed and finalized KETCHUP options.
    """

    # set default values for every item
    model_options: dict[str, str | bool | int | None] = {
        # primary items (model creation)
        'input_format': "kfit",  # input file format
        'directory_model': os.path.join(os.getcwd(), "data"),  # location of model and mechanism files
        'filename_model': "model.xlsx",
        'filename_mechanism': "mechanism.xlsx",
        'directory_data': os.path.join(os.getcwd(), "data"),  # location of data files
        'filename_data': "data.xlsx",
        'data_type': 'static',  # static or dynamic data
        'data_format': "kfit", # format of data. use "custom" to indicate a user-defined data parsing function
        'data_parse_function': None, # custom data parsing function
        'data_strainer_header': None, # header info needed for strainer data_format import
        'data_selection': None, # selection dict or list to update data used for computations. None selects all
        'directory_output': os.getcwd(),  # location of output files
        'model_name': "k-model",  # used in output
        'mechanism_type': "elemental",  # rate law to follow
        # secondary items  (model solution)
        'debug': False,  # flag to print additional runtime output
        'flag_output_sbml': False,  # flag to output results to SBML file
        'seedvalue': 0, # integer or "time" to use clock time
        'distribution': "uniform",  # distribution for initialization
        'filename_solver_opt': None,  # file for solver options
        'time_delay': 0, # time-delay of beginning of simulations; can be int, float, dict or list
    }

        # update items based on passed dictionary
    for key,value in user_options.items():
        model_options[key] = value

    # update items based on program options file command line argument, if any
    try:
        if cmd_args.program_options:
            from ktools.io import read_options_file
            fn = cmd_args.program_options
            # pre-process items from option file
            for key,value in ketchup_process_model_options(read_options_file(fn)).items():
                model_options[key] = value
    except AttributeError:
        pass

    # validate data_format for each data_type
    # TODO: add more data_formats
    if model_options['data_type'] == 'static':
        if model_options['data_format'] not in ("kfit", "k-fit"):
            import warnings
            warnings.warn(f"Warning: Unknown data format for static data")
    elif model_options['data_type'] == 'dynamic':
        if model_options['data_format'] in ["custom"]:
            pass
        elif model_options['data_format'] in ("kfit", "k-fit"):
            model_options['data_format'] = "flat" # change to default value for dynamic
        elif model_options['data_format'] not in ("flat", "strainer"):
            import warnings
            warnings.warn(f"Warning: Unknown data format for static data. Assuming flat")
            model_options['data_format'] = "flat"
    elif model_options['data_type'] in ('custom'):
        # TODO: implement user-defined custom data functions
        pass
    else:
        import warnings
        warnings.warn(f"Warning: Unknown data type")

    #print (f"{model_options['data_type'] = } {model_options['data_format'] = }")

    # update seed and solver options items based on arguments, if any
    # only updated to valid values, otherwise use existing
    try:
        seedvalue = int(cmd_args.seed)
    except (IndexError, AttributeError, TypeError) as err:
        # print (f"Exception: {type(err).__name__}")
        seedvalue = model_options['seedvalue']
    except (ValueError) as err:
        # print (f"Exception: {type(err).__name__}")
        # use string 'time' for time-based seed
        #print(str(cmd_args.seed).lower())
        if str(cmd_args.seed).lower() in ('time', 't'):
            import time
            seedvalue = int(time.time() * 1000)  # ms since epoch
        else:
            seedvalue = model_options['seedvalue']
    #else:
    #    seedvalue = model_options['seedvalue']
    # check validity of seed and assign value
    seedvalue = seedvalue % (2 ** 32 - 1)  # seed must be between 0 and 2**32 - 1
    model_options['seedvalue'] = seedvalue

    # update solver options items based on arguments, if any
    # read filename for solver options

    try:
        if cmd_args.solver_options:
            _tmp_fn = str(cmd_args.solver_options)
            if (not _tmp_fn.startswith("/")) and ("/" in _tmp_fn):
                fn = os.path.join(os.getcwd(), _tmp_fn)
            else:
                fn = f"{_tmp_fn}"
            if os.path.exists(fn):
                model_options['filename_solver_opt'] = fn
            else:
                import warnings
                warnings.warn(f"Warning: provided solver options filename '{fn}' does not exist. The solver will try using the name from program options.")
                raise FileNotFoundError
    except (ValueError, IndexError, AttributeError, FileNotFoundError) as err:
        # fall back to the passed dictionary or name from item in program options file
        if model_options['filename_solver_opt']:
            _tmp_fn = str(model_options['filename_solver_opt'])
            if (not _tmp_fn.startswith("/")) and ("/" in _tmp_fn):
                fn = os.path.join(os.getcwd(), _tmp_fn)
            else:
                fn = f"{_tmp_fn}"
            if os.path.exists(_tmp_fn):
                model_options['filename_solver_opt'] = _tmp_fn
            else:
                import warnings
                warnings.warn(f"Warning: solver options file {fn} does not exist. The solver will use its default options.")
                model_options['filename_solver_opt'] = None

    # time-delay from argument
    try:
        if cmd_args.time_delay:
            model_options['time_delay'] = float(cmd_args.time_delay)
    except AttributeError:
        pass

    return model_options


def ketchup_generate_model(ketchup_options: dict[str, str | bool | int | None]) -> pyomo.core.base.PyomoModel.ConcreteModel:
    """
    Generates a Pyomo Concrete Model for subsequent computations and analysis by processing the contents of the program options.

    Parameters
    ----------
    ketchup_options : dict[str, str | bool | int | None]
        A valid KETCHUP option dictionary containing the processed KETCHUP options that define the problem to solve.

    Returns
    -------
    pyomo.core.base.PyomoModel.ConcreteModel
        A KETCHUP Pyomo ConcreteModel object.
    """

    import pyomo.environ
    from pyomo.environ import Constraint, Block, Objective
    import cobra.core
    import ktools
    from ktools.core import create_data_dict, create_dynamic_data_dict, parse_time_delay, create_initial_model
    from ktools.io import read_kfit_model_xlsx
    from ktools.io import read_kfit_data_xlsx, read_flat_data, read_strainer_data_xlsx
    from os.path import join

    # read model and mechanism files
    if ketchup_options['input_format'].lower() in ("kfit", "k-fit"):
        m_model, mech_df = read_kfit_model_xlsx(join(ketchup_options['directory_model'],
                                                     ketchup_options['filename_model']),
                                                join(ketchup_options['directory_model'],
                                                     ketchup_options['filename_mechanism']),
                                                mech_type=ketchup_options['mechanism_type'],
                                                debug=ketchup_options['debug'])
    else:
        raise ValueError(f"Invalid input format. Currently only supports K-FIT style model files.")

    if ketchup_options['data_type'].lower() in ("static"):
        if ketchup_options['data_format'].lower() in ("kfit", "k-fit"):
            data_df = read_kfit_data_xlsx(join(ketchup_options['directory_data'],
                                               ketchup_options['filename_data']))
            data_dict = create_data_dict(data_df)
        elif ketchup_options['data_format'].lower() in ("custom"):
            raise ValueError(f"Currently static only supports K-FIT style.")
        else:
            raise ValueError(f"Invalid data format. Currently static only supports K-FIT style.")
    elif ketchup_options['data_type'].lower() in ("dynamic"):
        if ketchup_options['data_format'].lower() in ("flat"):
            data_df = read_flat_data(join(ketchup_options['directory_data'],
                                          ketchup_options['filename_data']), "dynamic")
            data_dict = create_dynamic_data_dict(data_df, ketchup_options['data_selection'])
        elif ketchup_options['data_format'].lower() in ("strainer"):
            if not ketchup_options['data_strainer_header']:
                raise ValueError(f"Strainer requires definition of header dictionary.")
            data_df = read_strainer_data_xlsx(join(ketchup_options['directory_data'],
                                                   ketchup_options['filename_data']),
                                              ketchup_options['data_strainer_header'])
            data_dict = create_dynamic_data_dict(data_df, ketchup_options['data_selection'])
        elif ketchup_options['data_format'].lower() in ("custom"):
            raise ValueError(f"Custom not yet implemented.")
        elif ketchup_options['data_format'].lower() in ("kfit", "k-fit"):
            raise ValueError(f"Dynamic data cannot use kfit data format.")
        else:
            raise ValueError(f"Unknown dynamic data format.")
        #print (data_dict)

        # create time delay in format for use with the data stream
        dict_tde = parse_time_delay(ketchup_options['time_delay'], data_dict.keys())

        print ("End of dynamic data parsing")

    else:
        raise ValueError(f'Invalid data type. Currently only supports "static" and "dynamic".')


    if ketchup_options['data_type'].lower() in ("static"):
        ketchup_model = create_initial_model(m_model, mech_df, data_dict,
                                             seedvalue=ketchup_options['seedvalue'],
                                             distribution=ketchup_options['distribution'],
                                             mech_type=ketchup_options['mechanism_type'])
    elif ketchup_options['data_type'].lower() in ("dynamic"):
        ketchup_model = create_initial_model(m_model, mech_df, data_dict,
                                             seedvalue=ketchup_options['seedvalue'],
                                             distribution=ketchup_options['distribution'],
                                             tde=dict_tde,
                                             mech_type=ketchup_options['mechanism_type'])
    print ("Initial model created")
    try:
        ketchup_model.name = str(ketchup_options['model_name'])
    except NameError:
        ketchup_model.name = 'unknown'
    
    experiments = []
    for i, d in enumerate(data_dict.keys()):
        ketchup_model.key = d
        if ketchup_options['data_type'].lower() in ("static"):
            ketchup_model.add_component(f'experiment{i}', Block(rule=ktools.core.create_sMB))
        elif ketchup_options['data_type'].lower() in ("dynamic"):
            ketchup_model.add_component(f'experiment{i}', Block(rule=ktools.core.create_dMB))
        experiments.append(eval(f"ketchup_model.experiment{i}"))
        print(f"dataset included: {d}")

    print("End of dataset inclusion")
    ketchup_model.add_component('block_list', pyomo.environ.Set(initialize=experiments))

    # currently only static analysis has basis constraints
    if ketchup_options['data_type'].lower() in ("static"):
        ketchup_model.reaction_rate = Constraint(ketchup_model.block_list,
                                                 ketchup_model.experiment0.REACTIONS,
                                                 rule=ktools.core.net_reaction_rate)

        try:
            basis_expt = str(ketchup_options['basis_id'])
        except KeyError:
            basis_expt = 'WT' if 'WT' in data_dict else data_dict[0]

    # create objective function
    ketchup_model.obj = Objective(sense=pyomo.environ.minimize,
                                  expr=sum(b.error for b in experiments)
                                  )

    # ketchup_model.experiment0.vf.pprint()
    if ketchup_options['mechanism_type'] == 'elemental':
        def ref_conc_constraint(m, s):
            return m.experiment0.c[s] == 1.0

        # fix wild-type fluxes
        for r in data_dict[basis_expt]:
            ketchup_model.experiment0.rate[r].fix(data_dict[basis_expt][r][0])

        ketchup_model.ref_conc_constraint = Constraint(ketchup_model.experiment0.SPECIES,
                                                       rule=ref_conc_constraint)
        ketchup_model.vf_rate = Constraint(ketchup_model.block_list,
                                           ketchup_model.ELEMENTALSTEP_F,
                                           rule=ktools.core.elemental_vf)
        ketchup_model.vr_rate = Constraint(ketchup_model.block_list,
                                           ketchup_model.ELEMENTALSTEP_R,
                                           rule=ktools.core.elemental_vr)
        ketchup_model.es_net  = Constraint(ketchup_model.block_list,
                                           ketchup_model.ELEMENTALSTEP_F,
                                           rule=ktools.core.es_net_balance)

    if ketchup_options['data_type'].lower() in ("dynamic"):
        if ketchup_options['mechanism_type'] == 'michaelis-menten':
            # TODO: as part of line by line processing extension, allow michaelis-mente processing
            for i, b in enumerate(ketchup_model.block_list):
                b.add_component('reaction_rate', Constraint(b.time, ketchup_model.experiment0.REACTIONS,
                                 rule = ktools.core.d_net_reaction_rate)
                                )
        # TODO: move into fork or wrap into another function to allow for use in static
        if ketchup_options['mechanism_type'] == 'custom':
            import re
            for i, b in enumerate(ketchup_model.block_list):
                for rxn in list(ketchup_model.unique_consts['rxns'].keys()):
                    rate_law = ketchup_model.unique_consts['rxns'][rxn]
                    for k in list(ketchup_model.unique_consts.keys())[:-1]:
                        for ss in ketchup_model.unique_consts[k]:
                            rxn_check = ss.split('+')[0];
                            s = ss.split('+')[1]
                            if rxn_check == rxn: rate_law = rate_law.replace(f'{k}[{s}]',
                                                                             f'b.model().{k}[\'{rxn}+{s}\']')
                    # replace metabolite concentrations expressions
                    for x in re.findall(r'([^~TIMS]\[.*?\])', rate_law):

                        if '[E]' not in x: rate_law = rate_law.replace(f'{x[0]}[{x[2:-1]}]',
                                                                       f'{x[0]}b.c[t,\'{x[2:-1]}\']')
                    # replace enzyme expression
                    rate_law = rate_law.replace('[E]', f'b.e[t,\'{rxn}_ENZ\']')

                    def rate_law_func(b, t):
                        return eval(f'b.rate[t,\'{rxn}\']') == eval(rate_law)

                    b.add_component(f'rate_law_{i}_{rxn}', Constraint(b.time, rule=rate_law_func)
                                    )
                # set initial conditions
                key = b.key
                data = b.data
                #print (data[key])
                c_list = [i[1] for i in b.c.keys() if i[0] == 0] # list of metabolites at time 0
                for d in list(data[key]['t0'].keys()):
                    if d in c_list:
                        b.c[0, d] = data[key]['t0'][d]
                        b.c[0, d].fixed = True
        else:
            raise ValueError(f"Dynamic currently requires michaelis-menten or custom mechanisms and rate laws.")

    return ketchup_model


def solve_ketchup_model(ketchup_model: pyomo.environ.ConcreteModel,
                        ketchup_options: dict[str, str | bool | int | None]) -> pyomo.opt.results.results_.SolverResults:
    """
    Solves Pyomo ConcreteModel using solver options file. Currently, uses `IPOPT` solver.

    Parameters
    ----------
    ketchup_model : pyomo.environ.ConcreteModel
        The Pyomo ConcreteModel representing the kinetic model.
    ketchup_options : dict[str, str | bool | int | None]
        A valid KETCHUP option dictionary containing the processed KETCHUP options that define the problem to solve,
        including the filename of the solver option file.

    Returns
    -------
    pyomo.opt.results.results_.SolverResults
        The result object containing the solver's output. Includes solver status.

    Raises
    ------
    ValueError
        Raised if the solver encounters an error during execution.
    """
    
    solver = pyomo.opt.SolverFactory('ipopt')
    solver.options.option_file_name = ketchup_options['filename_solver_opt']

    try:
        results = solver.solve(ketchup_model, tee=True, symbolic_solver_labels=True)
        #total_error = sum( b.error.value for exps in experiments for b in exps[:] )
        status = str(results.Solver[0]['Termination condition']) 
    except ValueError:
        status = 'Status Error'

    return results


def ketchup_output_write(results: pyomo.opt.results.results_.SolverResults,
                         ketchup_model: pyomo.environ.ConcreteModel,
                         ketchup_options: dict[str, str | bool | int | None],
                         time_start = None, time_end = None ) -> None:
    """
    Outputs solved model results and duration of computations

    Parameters
    ----------
    results : pyomo.opt.results.results_.SolverResults
        The solved KETCHUP results which containing both the solution and termination status.
    ketchup_model : pyomo.environ.ConcreteModel
        The Pyomo ConcreteModel representing the KETCHUP kinetic model.
    ketchup_options : dict[str, str | bool | int | None]
        A valid KETCHUP option dictionary containing the processed KETCHUP options that define the problem to solve,
        including output directives.

    Returns
    -------
    None
    """
    from ktools.io import result_dump, create_sbml_kinetic_model

    seedvalue = ketchup_options['seedvalue']
    output_data_type_category = ketchup_options['data_type']
    mechanism_type_category = ketchup_options['mechanism_type']

    try:
        status = str(results.Solver[0]['Termination condition'])
    except ValueError:
        status = 'Status Error'

    result_dump(os.path.join(ketchup_options['directory_output'], f"{ketchup_options['model_name']}_{status}_results"),
                seedvalue, ketchup_model, time_end - time_start, status, output_data_type_category,
                mechanism_type_category)

    # create SBML for the model at the solution and output to file
    if ketchup_options['flag_output_sbml']:
        kmodel_sbml = create_sbml_kinetic_model(ketchup_model)
        with open(os.path.join(ketchup_options['directory_output'],
                               f"{ketchup_options['model_name']}_{status}_results_{seedvalue}.xml"),
                  'w') as output_file:
            output_file.write(kmodel_sbml)

    return
